# From One to Many: Multi-Agent Systems

## Customer Support in the Real World
- Types of custoemr tickets
    - Billing disputes requiring financial knowledge
    - Technical issues needing engineering support
    - Legal compliance questions demanding regulatory knowledge
    - Product recommendations calling for sales acumen

|Ticket Type|Knowledge Resources|Tools to Access|
|---|---|---|
|Billing disputes|Internal finance documentation, payment policy wiki, transaction logs|Secure payment APIs, CRM with billing integration|
|Technical issues|Engineering runbooks, system architecture docs, incident postmortems|Observability tools (e.g. Datadog) ticketing system, internal dashboards|
|Legal compliance questions|Legal knowledge base, compliance manuals, GDPR/CCPA documentation|Contract management system, legal Q&A assistant, document retrieval tools|
|Product recommendations|Product feature matrix, customer personas, sales playbooks|

## The Problem with Single Agents
- Increasingly complex logic
    - Models using prompts with a high amount of if-else scenarios and edge-cases
- Tool Overload
    - Agentic systems where a single model needs to call a wide variety of tools

## Multi-Agent Systems
- Single Agent Systems
    - A single model equipped with appropriate tools and instructions executes workflows in a loop
- Multi-Agent Systems
    - Execute workflows across multiple coordinated agents

Multi-agent systems can be designed in numerous ways for specific workflows, but two borad common patterns have emerged:

### Manager Pattern

![The Manager Pattern](<he Manager Pattern.png>)
There is a central model that orchestrates a network of agents to perform specific tasks.

This pattern is ideal for workflows where you only want one agent to control workflow execution and have access to the user

![The Manager Pattern Applied](<The Manager Pattern Applied.png>)

In the example of the customer support agent, think of this as interacting with the head of customer suport, who delegates tasks to the appropriate team member, in this case billing, but manages the communication with the client.

### The Decentralized Pattern

![The Decentralized Pattern](<The Decentralized Pattern.png>)

The Decentralized Pattern relies on the concept of handoff. Here, a triage agent hands off the request to another agent, who can handle the task end-to-end, including communicating with the user.

This pattern is especially effective for scenarios like conversation triage, or whenever you prefer specialized agents to fully take over certain tasks without the original agent needing to remain involved

![The Decentralized Pattern Applied](<The Decentralized Pattern Applied.png>)

In the customer support example, think of this as first interacting with a customer support agent, that connects you with the relevant expert for your use-case, and that expert then owns your ticket.
